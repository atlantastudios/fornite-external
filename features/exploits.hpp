#pragma once
#include "../core/sdk.hpp"
#include "../core/settings.hpp"
#include "../core/offsets.hpp"

namespace exploits {
	
	void update() {
		if (!cache::local_pawn) return;
		
		// Spinbot
		if (settings::Exploits::spinbot) {
			uintptr_t mesh = read<uintptr_t>(cache::local_pawn + MESH);
			if (mesh) {
				static auto cached_rotation = read<uintptr_t>(mesh + MESH_ROTATION);
				
				if (GetAsyncKeyState(VK_LBUTTON)) {
					write(mesh + MESH_ROTATION, Vector3(1, rand() % 361, 1));
				} else {
					write(mesh + MESH_ROTATION, cached_rotation);
				}
			}
		}
		
		// Player backwards
		if (settings::Exploits::playerbackwards) {
			uintptr_t mesh = read<uintptr_t>(cache::local_pawn + MESH);
			if (mesh) {
				static bool has_turned = false;
				static auto cached_rotation = read<Vector3>(mesh + MESH_ROTATION);
				
				if (!has_turned) {
					Vector3 current_rotation = read<Vector3>(mesh + MESH_ROTATION);
					current_rotation.y += 180;
					if (current_rotation.y > 360) current_rotation.y -= 360;
					else if (current_rotation.y < 0) current_rotation.y += 360;
					write(mesh + MESH_ROTATION, current_rotation);
					has_turned = true;
				}
			}
		}
		
		// FOV changer
		static bool fov_reset = true;
		if (settings::Exploits::fovchanger) {
			fov_reset = false;
			write(cache::player_controller + FOV_CHANGER_1, settings::Exploits::fovchanger_value);
			write(cache::player_controller + FOV_CHANGER_2, settings::Exploits::fovchanger_value);
		} else if (!fov_reset) {
			write(cache::player_controller + FOV_CHANGER_3, settings::Exploits::fovchanger_value);
			write(cache::player_controller + FOV_CHANGER_4, settings::Exploits::fovchanger_value);
			fov_reset = true;
		}
	}
}

